import "./chunk-G3PMV62Z.js";

// node_modules/@minima-global/mds/dist/helpers.js
function commandHandler(command, args) {
  let commandString = command;
  let callback;
  let payload;
  if (args.length > 0) {
    if (typeof args[args.length - 1] === "function") {
      callback = args.pop();
      if (args.length > 0) {
        payload = args[0];
      }
    } else {
      payload = args[0];
    }
  }
  if (payload) {
    if (typeof payload === "string") {
      commandString += ` ${payload}`;
    } else if (typeof payload === "object") {
      if (payload.params) {
        const payloadString = Object.entries(payload.params).filter(([_, value]) => value !== void 0).map(([key, value]) => {
          if (typeof value === "object" && value !== null) {
            return `${key}:${JSON.stringify(value)}`;
          }
          return `${key}:${value}`;
        }).join(" ");
        commandString += payloadString ? ` ${payloadString}` : "";
      } else {
        const payloadString = Object.entries(payload).filter(([_, value]) => value !== void 0).map(([key, value]) => {
          if (typeof value === "object" && value !== null) {
            return `${key}:${JSON.stringify(value)}`;
          }
          return `${key}:${value}`;
        }).join(" ");
        commandString += payloadString ? ` ${payloadString}` : "";
      }
    }
  }
  return { commandString, callback };
}
function createCommandFunction(command) {
  return (...args) => {
    const { commandString, callback } = commandHandler(command, args);
    return new Promise((resolve) => {
      httpPostAsync("cmd", commandString, (data) => {
        resolve(data);
        if (callback && typeof callback === "function") {
          callback(data);
        }
      });
    });
  };
}

// node_modules/@minima-global/mds/dist/mds.js
var MDS_MAIN_CALLBACK;
var API_CALLS = [];
var MDS = {
  filehost: "",
  mainhost: "",
  minidappuid: "",
  testhost: "",
  TEST_MODE: false,
  logging: false,
  DEBUG_HOST: null,
  DEBUG_PORT: 0,
  DEBUG_MINIDAPPID: "",
  init: (callback) => {
    MDS.log("MDS Inited");
    if (isTestEnvironment()) {
      MDS.TEST_MODE = true;
      MDS.minidappuid = MDS.DEBUG_MINIDAPPID || "0x00";
      MDS.filehost = `https://${MDS.DEBUG_HOST}:${MDS.DEBUG_PORT}/`;
      MDS.mainhost = `http://${MDS.DEBUG_HOST}:${MDS.DEBUG_PORT}/`;
      MDS.testhost = `http://${MDS.DEBUG_HOST}:${MDS.DEBUG_PORT}/`;
      MDS_MAIN_CALLBACK = callback;
      if (callback) {
        callback({ event: "inited", data: null });
      }
      return;
    }
    if (MDS.form.getParams("MDS_LOGGING") != null) {
      MDS.logging = true;
    }
    var host = window.location.hostname;
    var port = Number(window.location.port);
    MDS.minidappuid = MDS.form.getParams("uid");
    if (MDS.DEBUG_HOST != null) {
      MDS.log("DEBUG Settings Found..");
      host = MDS.DEBUG_HOST;
      port = MDS.DEBUG_PORT;
    }
    if (MDS.minidappuid == null) {
      MDS.minidappuid = MDS.DEBUG_MINIDAPPID;
    }
    if (MDS.minidappuid == "0x00") {
      MDS.log("No MiniDAPP UID specified.. using test value");
    }
    MDS.filehost = "https://" + host + ":" + port + "/";
    MDS.mainhost = "https://" + host + ":" + port + "/mdscommand_/";
    MDS.testhost = "https://" + host + ":" + port + "/";
    MDS.log("MDS HOST  : " + MDS.filehost);
    MDS_MAIN_CALLBACK = callback;
    PollListener();
    MDSPostMessage({ event: "inited" });
  },
  log: (data) => {
    console.log("Minima @ " + (/* @__PURE__ */ new Date()).toLocaleString() + " : " + data);
  },
  notify: (output) => {
    httpPostAsync(MDS.mainhost + "notify?uid=" + MDS.minidappuid, output);
  },
  notifycancel: () => {
    httpPostAsync("notifycancel", "*");
  },
  cmd: new Proxy({}, {
    get: (target, prop) => {
      if (prop in target) {
        return target[prop];
      }
      const commandFunction = createCommandFunction(prop);
      target[prop] = commandFunction;
      return commandFunction;
    }
  }),
  sql: (command, callback) => {
    return new Promise((resolve) => {
      httpPostAsync("sql", command, (data) => {
        resolve(data);
        if (callback) {
          callback(data);
        }
      });
    });
  },
  dapplink: (dappname, callback) => {
    return new Promise((resolve) => {
      httpPostAsync("dapplink", dappname, (result) => {
        resolve(result);
        if (callback) {
          callback(result);
        }
      });
    });
  },
  api: {
    call: (dappname, data, callback) => {
      var rand = "" + Math.random() * 1e9;
      var callitem = {};
      callitem.id = rand;
      callitem.callback = callback;
      API_CALLS.push(callitem);
      var commsline = dappname + "&request&" + rand + "&" + data;
      httpPostAsync("api", commsline);
    },
    reply: (dappname, id, data, callback) => {
      var commsline = dappname + "&response&" + id + "&" + data;
      httpPostAsync("api", commsline, callback);
    }
  },
  net: {
    GET: (url, callback) => {
      httpPostAsync("net", url, callback);
    },
    POST: (url, data, callback) => {
      var postline = url + "&" + data;
      httpPostAsync("netpost", postline, callback);
    }
  },
  keypair: {
    get: (key, callback) => {
      return new Promise((resolve) => {
        var commsline = "get&" + key;
        httpPostAsync("keypair", commsline, (data) => {
          resolve(data);
          if (callback) {
            callback(data);
          }
        });
      });
    },
    set: (key, value, callback) => {
      return new Promise((resolve) => {
        var commsline = "set&" + key + "&" + value;
        httpPostAsync("keypair", commsline, (data) => {
          resolve(data);
          if (callback) {
            callback(data);
          }
        });
      });
    }
  },
  comms: {
    broadcast: (message, callback) => {
      var commsline = "public&" + message;
      httpPostAsync("comms", commsline, callback);
    },
    solo: (message, callback) => {
      var commsline = "private&" + message;
      httpPostAsync("comms", commsline, callback);
    }
  },
  file: {
    list: (folder, _, callback) => {
      var commsline = "list&" + folder;
      httpPostAsync("file", commsline, callback);
    },
    save: (filename, text, callback) => {
      var commsline = "save&" + filename + "&" + text;
      httpPostAsync("file", commsline, callback);
    },
    savebinary: function(filename, hexdata, callback) {
      var commsline = "savebinary&" + filename + "&" + hexdata;
      httpPostAsync("file", commsline, callback);
    },
    load: (filename, _, callback) => {
      var commsline = "load&" + filename;
      httpPostAsync("file", commsline, callback);
    },
    loadbinary(filename, _, callback) {
      var commsline = "loadbinary&" + filename;
      httpPostAsync("file", commsline, callback);
    },
    delete: (filename, _, callback) => {
      var commsline = "delete&" + filename;
      httpPostAsync("file", commsline, callback);
    },
    getpath: (filename, _, callback) => {
      var commsline = "getpath&" + filename;
      httpPostAsync("file", commsline, callback);
    },
    makedir: (filename, _, callback) => {
      var commsline = "makedir&" + filename;
      httpPostAsync("file", commsline, callback);
    },
    copy: (filename, newfilename, callback) => {
      var commsline = "copy&" + filename + "&" + newfilename;
      httpPostAsync("file", commsline, callback);
    },
    move: (filename, newfilename, callback) => {
      var commsline = "move&" + filename + "&" + newfilename;
      httpPostAsync("file", commsline, callback);
    },
    download: (url, _, callback) => {
      var commsline = "download&" + url;
      httpPostAsync("file", commsline, callback);
    },
    upload: (file, _, callback) => {
      _recurseUploadMDS(file, 0, callback);
    },
    listweb: (folder, _, callback) => {
      var commsline = "listweb&" + folder;
      httpPostAsync("file", commsline, callback);
    },
    copytoweb: (file, webfile, callback) => {
      var commsline = "copytoweb&" + file + "&" + webfile;
      httpPostAsync("file", commsline, callback);
    },
    deletefromweb: (file, _, callback) => {
      var commsline = "deletefromweb&" + file;
      httpPostAsync("file", commsline, callback);
    }
  },
  executeRaw: (command, callback) => {
    return new Promise((resolve) => {
      httpPostAsync("cmd", command, (data) => {
        resolve(data);
        if (callback) {
          callback(data);
        }
      });
    });
  },
  form: {
    getParams: (parameterName) => {
      var _a;
      if (isTestEnvironment()) {
        return null;
      }
      var result = null;
      var tmp = [];
      var items = window.location.search.substr(1).split("&");
      for (var index = 0; index < items.length; index++) {
        tmp = ((_a = items[index]) == null ? void 0 : _a.split("=")) ?? [];
        if (tmp[0] === parameterName) {
          result = decodeURIComponent(tmp[1] ?? "");
        }
      }
      return result;
    }
  },
  util: {
    hexToBase64: (hexstring) => {
      var thex = hexstring;
      if (hexstring.startsWith("0x")) {
        thex = hexstring.substring(2);
      }
      return btoa((thex.match(/\w{2}/g) || []).map(function(a) {
        return String.fromCharCode(parseInt(a, 16));
      }).join(""));
    },
    base64ToHex: (base64) => {
      const raw = atob(base64);
      let result = "";
      for (let i = 0; i < raw.length; i++) {
        const hex = raw.charCodeAt(i).toString(16);
        result += hex.length === 2 ? hex : "0" + hex;
      }
      return result.toUpperCase();
    },
    base64ToArrayBuffer: (base64) => {
      const binary_string = window.atob(base64);
      const len = binary_string.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
      }
      return bytes.buffer;
    },
    getStateVariable: (coin, port) => {
      var statvars = coin.state;
      if (Array.isArray(statvars)) {
        var len = statvars.length;
        for (var i = 0; i < len; i++) {
          var state = statvars[i];
          if ((state == null ? void 0 : state.port) == port) {
            return state.data;
          }
        }
      }
      return void 0;
    }
  }
};
function MDSPostMessage(json) {
  if (MDS_MAIN_CALLBACK) {
    if (json.event == "MDSAPI") {
      if (!json.data.request) {
        var found = "";
        var len = API_CALLS.length;
        for (var i = 0; i < len; i++) {
          if (API_CALLS[i].id == json.data.id) {
            found = json.data.id;
            var reply = {};
            reply.status = json.data.status;
            reply.data = json.data.message;
            API_CALLS[i].callback(reply);
          }
        }
        if (found != "") {
          API_CALLS = API_CALLS.filter(function(apic) {
            return apic.id != found;
          });
        } else {
        }
        return;
      }
    }
    MDS_MAIN_CALLBACK(json);
  }
}
var PollCounter = 0;
var PollSeries = 0;
function PollListener() {
  var pollhost = MDS.mainhost + "poll?uid=" + MDS.minidappuid;
  var polldata = "series=" + PollSeries + "&counter=" + PollCounter;
  httpPostAsyncPoll(pollhost, polldata, function(msg) {
    if (PollSeries != msg.series) {
      PollSeries = msg.series;
      PollCounter = msg.counter;
    } else {
      if (msg.status == true) {
        PollCounter = msg.response.counter + 1;
        MDSPostMessage(msg.response.message);
      }
    }
    PollListener();
  });
}
function postMDSFail(command, params, status) {
  if (MDS.logging) {
    MDS.log("** An error occurred during an MDS command!");
  }
  var errormsg = {
    event: "MDSFAIL",
    data: {
      command,
      params,
      status
    }
  };
  MDSPostMessage(errormsg);
}
function httpPostAsync(theUrl, params, callback) {
  var finalurl = MDS.TEST_MODE ? MDS.testhost : MDS.mainhost;
  finalurl += theUrl + "?uid=" + MDS.minidappuid;
  var testUrl = "http://" + MDS.DEBUG_HOST + ":" + MDS.DEBUG_PORT + "/" + params;
  if (MDS.logging) {
    MDS.log("POST_RPC:" + finalurl + " PARAMS:" + params);
  }
  if (MDS.TEST_MODE) {
    fetch(testUrl).then((response) => response.json()).then((data) => {
      if (MDS.logging) {
        MDS.log("RESPONSE:" + JSON.stringify(data));
      }
      if (callback) {
        callback(data);
      }
    }).catch((error) => {
      postMDSFail(finalurl, params, error);
    });
    return;
  }
  var xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function() {
    var status = xmlHttp.status;
    if (xmlHttp.readyState == XMLHttpRequest.DONE) {
      if (status === 0 || status >= 200 && status < 400) {
        if (MDS.logging) {
          MDS.log("RESPONSE:" + xmlHttp.responseText);
        }
        if (callback) {
          try {
            const responseJson = JSON.parse(xmlHttp.responseText);
            callback(responseJson);
          } catch (error) {
            console.error("Failed to parse response as JSON", error);
          }
        }
      } else {
        postMDSFail(finalurl, params, xmlHttp.status);
      }
    }
  };
  xmlHttp.open("POST", finalurl, true);
  if (xmlHttp.overrideMimeType) {
    xmlHttp.overrideMimeType("text/plain; charset=UTF-8");
  }
  xmlHttp.send(encodeURIComponent(params));
}
function httpPostAsyncPoll(theUrl, params, callback) {
  if (MDS.logging) {
    MDS.log("POST_POLL_RPC:" + theUrl + " PARAMS:" + params);
  }
  if (MDS.TEST_MODE) {
    fetch(theUrl).then((response) => response.json()).then((data) => {
      if (MDS.logging) {
        MDS.log("RESPONSE:" + JSON.stringify(data));
      }
      if (callback) {
        callback(data);
      }
    }).catch((error) => {
      setTimeout(() => {
        PollListener();
      }, 1e4);
    });
    return;
  }
  var xmlHttp = new XMLHttpRequest();
  xmlHttp.onreadystatechange = function() {
    var status = xmlHttp.status;
    if (xmlHttp.readyState == XMLHttpRequest.DONE) {
      if (status === 0 || status >= 200 && status < 400) {
        if (MDS.logging) {
          MDS.log("RESPONSE:" + xmlHttp.responseText);
        }
        if (callback) {
          try {
            const responseJson = JSON.parse(xmlHttp.responseText);
            callback(responseJson);
          } catch (error) {
            console.error("Failed to parse response as JSON", error);
          }
        }
      } else {
        postMDSFail(theUrl, params, xmlHttp.status);
      }
    }
  };
  xmlHttp.addEventListener("error", function() {
    MDS.log("Error Polling - reconnect in 10s");
    setTimeout(function() {
      PollListener();
    }, 1e4);
  });
  xmlHttp.open("POST", theUrl, true);
  if (xmlHttp.overrideMimeType) {
    xmlHttp.overrideMimeType("text/plain; charset=UTF-8");
  }
  xmlHttp.send(encodeURIComponent(params));
}
function _recurseUploadMDS(thefullfile, chunk, callback) {
  var filename = thefullfile.name;
  var filesize = thefullfile.size;
  var chunk_size = 1024 * 1024;
  var allchunks = Math.ceil(filesize / chunk_size);
  if (chunk > allchunks - 1) {
    return;
  }
  var startbyte = chunk_size * chunk;
  var endbyte = startbyte + chunk_size;
  if (endbyte > filesize) {
    endbyte = filesize;
  }
  var filepiece = thefullfile.slice(startbyte, endbyte);
  var formdata = new FormData();
  formdata.append("uid", MDS.minidappuid);
  formdata.append("filename", filename);
  formdata.append("filesize", filesize);
  formdata.append("allchunks", allchunks);
  formdata.append("chunknum", chunk);
  formdata.append("fileupload", filepiece);
  var request = new XMLHttpRequest();
  request.open("POST", "/fileuploadchunk.html");
  request.onreadystatechange = function() {
    var status = request.status;
    if (request.readyState == XMLHttpRequest.DONE) {
      if (status === 0 || status >= 200 && status < 400) {
        if (callback) {
          var resp = {};
          resp.status = true;
          resp.filename = filename;
          resp.size = filesize;
          resp.allchunks = allchunks;
          resp.chunk = chunk + 1;
          resp.start = startbyte;
          resp.end = endbyte;
          callback(resp);
        }
        if (callback) {
          _recurseUploadMDS(thefullfile, chunk + 1, callback);
        } else {
          _recurseUploadMDS(thefullfile, chunk + 1);
        }
      } else {
        if (callback) {
          var resp = {};
          resp.status = false;
          resp.error = request.responseText;
          resp.filename = filename;
          resp.size = filesize;
          resp.allchunks = allchunks;
          resp.chunk = chunk;
          resp.start = startbyte;
          resp.end = endbyte;
          callback(resp);
        }
        MDS.log("MDS FILEUPLOAD CHUNK ERROR: " + request.responseText);
      }
    }
  };
  request.send(formdata);
}
function isTestEnvironment() {
  return typeof window === "undefined" || MDS.TEST_MODE;
}

// node_modules/@minima-global/mds/dist/types.js
var MinimaEvents = {
  INITED: "inited",
  NEWBLOCK: "NEWBLOCK",
  MINING: "MINING",
  MINIMALOG: "MINIMALOG",
  MAXIMA: "MAXIMA",
  TIMER_10SECONDS: "MDS_TIMER_10SECONDS",
  TIMER_1HOUR: "MDS_TIMER_1HOUR",
  SHUTDOWN: "MDS_SHUTDOWN",
  PENDING: "MDS_PENDING",
  NEWCOIN: "NEWCOIN",
  NOTIFYCOIN: "NOTIFYCOIN",
  NOTIFYCASCADECOIN: "NOTIFYCASCADECOIN"
};
export {
  MDS,
  MinimaEvents,
  commandHandler,
  createCommandFunction,
  httpPostAsync
};
//# sourceMappingURL=@minima-global_mds.js.map
